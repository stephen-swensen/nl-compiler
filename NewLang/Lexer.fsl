{
module Swensen.NewLang.Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing

let lexeme lexbuf =
    LexBuffer<char>.LexemeString lexbuf

let keywords =
    [
        "open", OPEN
        "in", IN
        "if", IF
        "then", THEN
        "else", ELSE
        "null", NULL
        "type", TYPE
        "true", BOOL(true)
        "false", BOOL(false)
        "while", WHILE
        "break", BREAK
        "continue", CONTINUE
    ] |> Map.ofList
}

// These are some regular expression definitions
let digit = ['0'-'9']
let alpha = (['a' - 'z'] | ['A' - 'Z'])
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

rule tokenize = parse
| whitespace { tokenize lexbuf }
| newline    { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }

// math
| "+"   { PLUS }
| "-"   { MINUS }
| "*"   { TIMES }
| "**"  { POW }
| "/"   { DIV }

//logic
| "!"  { BANG }
| "&&" { ANDAND }
| "||" { OROR }
//| "^"  { XOR }

//compairson
| "!=" { NOTEQ }
| "==" { EQEQ }
| ">"  { GT }
| "<"  { LT }
| ">=" { GTEQ }
| "<=" { LTEQ }

//various
| "[" { LBRACKET }
| "]" { RBRACKET }
| "{" { LBRACE }
| "}" { RBRACE }
| "(" { LPAREN }
| ")" { RPAREN }
| "." { DOT }
| "," { COMMA }
| ";" { SEMICOLON }
| "="  { EQ }
| "<-" { SET }

//string literal
| '"' [^ '"']* '"' { STRING (let s = lexeme lexbuf in s.Substring(1, s.Length - 2)) }

//char literal
| ''' _ ''' { CHAR (let s = lexeme lexbuf in s.[1]) }

// Numeric constants
| digit+							  { INT32 (lexeme lexbuf |> int) }
| digit+('.'digit+)?(['e''E']digit+)? { DOUBLE (lexeme lexbuf |> float) }

// Names
| (alpha | '_')+(digit | alpha | '_')* 
    { 
        let input = (lexeme lexbuf).ToLower()
        match keywords |> Map.tryFind input with
        | Some(token) -> token
        | None -> NAME(input) 
    }

// EOF
| eof { EOF }