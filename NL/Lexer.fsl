{
module Swensen.NL.Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing

module EM = ErrorMessages

let lexeme lexbuf =
    LexBuffer<char>.LexemeString lexbuf

let range (lexbuf:LexBuffer<char>) =
    PositionRange(lexbuf.StartPos,lexbuf.EndPos)

let keywords =
    [
        "open", OPEN
        "in", IN
        "if", IF
        "then", THEN
        "else", ELSE
        "null", NULL
        "type", TYPE
        "true", BOOL(true)
        "false", BOOL(false)
        "while", WHILE
        "break", BREAK
        "continue", CONTINUE
        "default", DEFAULT
        "checked", CHECKED
        "unchecked", UNCHECKED
    ] |> Map.ofList
}

// These are some regular expression definitions
let digit = ['0'-'9']
let alpha = (['a' - 'z'] | ['A' - 'Z'])
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

rule tokenize = parse
| whitespace { tokenize lexbuf }
| newline    { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }

// math
| "+"   { PLUS }
| "-"   { MINUS }
| "*"   { TIMES }
| "**"  { POW }
| "/"   { DIV }

//logic
| "!"  { BANG }
| "&&" { ANDAND }
| "||" { OROR }
//| "^"  { XOR }

//compairson
| "!=" { NOTEQ }
| "==" { EQEQ }
| ">"  { GT }
| "<"  { LT }
| ">=" { GTEQ }
| "<=" { LTEQ }

//various
| "["  { LBRACKET }
| "]"  { RBRACKET }
| "{"  { LBRACE }
| "}"  { RBRACE }
| "("  { LPAREN }
| ")"  { RPAREN }
| "."  { DOT }
| ","  { COMMA }
| ";;" { DOUBLE_SEMICOLON }
| ";"  { SEMICOLON }
| "="  { EQ }
| "<-" { SET }

//verbatim string literal
| "@\"" ("\"\""|[^ '"'])* '"' { STRING (let s = lexeme lexbuf in s.Substring(2, s.Length - 3).Replace("\"\"", "\"")) }

//string literal with escape sequences
| '"' ( '\\'_ | [^ '\"' ] )* '"'
    { 
        let s = lexeme lexbuf 
        try
            STRING(System.Text.RegularExpressions.Regex.Unescape(s.Substring(1, s.Length - 2)))
        with e ->
            EM.Could_not_unescape_string_literal (range lexbuf) e.Message
            STRING("") //error recovery
    } 

//single quote char literal
| ''' "\\'" ''' { CHAR(''') }
//char literal with escape sequence (accepts zero or more chars with possible escape sequences and does error recovery)
| ''' [^ ''']* ''' 
    { 
        let s = lexeme lexbuf
        try //will throw if a) could not escape, or b) was more than one character
            let unescaped = System.Text.RegularExpressions.Regex.Unescape(s.Substring(1, s.Length - 2))
            if unescaped.Length <> 1 then
                EM.Char_literal_must_be_exactly_one_character (range lexbuf) unescaped
                CHAR(' ')
            else
                CHAR(s.[1]) 
        with e ->
            EM.Could_not_unescape_char_literal (range lexbuf) e.Message
            CHAR(' ') //error recovery
    } 

// Numeric constants
| digit+'y'
    {
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-1)
        match System.SByte.TryParse(input) with
        | true, value -> SBYTE(value)
        | _ ->
            EM.SByte_literal_out_of_range (range lexbuf) input
            SBYTE(0y) //error recovery
    }

| digit+"uy"
    {
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-2)
        match System.Byte.TryParse(input) with
        | true, value -> BYTE(value)
        | _ ->
            EM.Byte_literal_out_of_range (range lexbuf) input
            BYTE(0uy) //error recovery
    }

| digit+'s'
    {
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-1)
        match System.Int16.TryParse(input) with
        | true, value -> INT16(value)
        | _ ->
            EM.Int16_literal_out_of_range (range lexbuf) input
            INT16(0s) //error recovery
    }

| digit+"us"
    {
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-2)
        match System.UInt16.TryParse(input) with
        | true, value -> UINT16(value)
        | _ ->
            EM.UInt16_literal_out_of_range (range lexbuf) input
            UINT16(0us) //error recovery
    }

| digit+'u'
    {
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-1)
        match System.UInt32.TryParse(input) with
        | true, value -> UINT32(value)
        | _ ->
            EM.UInt32_literal_out_of_range (range lexbuf) input
            UINT32(0u) //error recovery
    }

| digit+'L'
    {
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-1)
        match System.Int64.TryParse(input) with
        | true, value -> INT64(value)
        | _ ->
            EM.Int64_literal_out_of_range (range lexbuf) input
            INT64(0L) //error recovery
    }

| digit+"UL"
    {
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-2)
        match System.UInt64.TryParse(input) with
        | true, value -> UINT64(value)
        | _ ->
            EM.UInt64_literal_out_of_range (range lexbuf) input
            UINT64(0UL) //error recovery
    }

| digit+							  
    {
        let input = lexeme lexbuf
        match System.Int32.TryParse(input) with
        | true, value -> INT32(value)
        | _ ->
            EM.Int32_literal_out_of_range (range lexbuf) input
            INT32(0) //error recovery
    }

| digit+'.'digit+(['e''E']digit+)?'f'
    { 
        let input = lexeme lexbuf
        let input = input.Substring(0, input.Length-1)
        match System.Single.TryParse(input) with
        | true, value -> SINGLE(value)
        | _ ->
            EM.Single_literal_out_of_range (range lexbuf) input
            SINGLE(0.0f) //error recovery
    }

| digit+'.'digit+(['e''E']digit+)? 
    { 
        let input = lexeme lexbuf
        match System.Double.TryParse(input) with
        | true, value -> DOUBLE (value)
        | _ ->
            EM.Double_literal_out_of_range (range lexbuf) input
            DOUBLE(0.0) //error recovery
    }

// Names
| (alpha | '_')+(digit | alpha | '_')* 
    { 
        let input = (lexeme lexbuf).ToLower()
        match keywords |> Map.tryFind input with
        | Some(token) -> token
        | None -> IDENT(input) 
    }

// EOF
| eof { EOF }

//unrecognized input error recovery
| _ 
    { 
        let input = lexeme lexbuf
        EM.Unrecognized_input (range lexbuf) input
        tokenize lexbuf 
    }
