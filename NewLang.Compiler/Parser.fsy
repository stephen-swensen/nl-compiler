%{

open Swensen.NewLang

//let parse_error msg =
//    failwithf "%A" msg

%}

%token <int> INT32
%token <float> DOUBLE
%token <string> STRING
%token <char> CHAR
%token <bool> BOOL
%token NULL TYPE
%token PLUS MINUS TIMES DIV POW BANG NOT
%token <string> NAME
%token IN EQ
%token LPAREN RPAREN
%token COMMA DOT SEMICOLON
%token OPEN REF
%token LBRACKET RBRACKET
%token EOF

%right SEMICOLON
%left PLUS MINUS
%left TIMES DIV
%right POW
%left CONCAT
%nonassoc UMINUS
%nonassoc BANG
%nonassoc NOT

%start start
%type <rexp> start
%type <rexp> rexp
%type <rexp list> rexpList

%type <tySig> tySig
%type <tySig list> tySigList

%%

start:
    | rexp EOF { $1 }

rexpList:
	| rexp { [$1] }
	| rexp COMMA rexpList { $1::$3 }
	| { [] }

longName:
	| NAME { $1 }
	| NAME DOT longName { $1 + "." + $3 }

tySigList:
	| tySig { [$1] }
	| tySig COMMA tySigList { $1::$3 }

tySig:
	| longName LBRACKET tySigList RBRACKET { TySig($1.ToLower(),$3) }
	| longName { TySig($1.ToLower(),[]) } 
	

rexp: 
    | rexp PLUS  rexp			 				{ rexp.NumericBinop(Plus, $1, $3, parseState.InputStartPosition 2) }
    | rexp MINUS rexp			 				{ rexp.NumericBinop(Minus, $1, $3, parseState.InputStartPosition 2) }
	| rexp TIMES rexp			 				{ rexp.NumericBinop(Times, $1, $3, parseState.InputStartPosition 2) }
	| rexp DIV rexp			 					{ rexp.NumericBinop(Div, $1, $3, parseState.InputStartPosition 2) }
	| rexp POW rexp			 					{ rexp.Pow($1, $3, parseState.InputStartPosition 2) }
	| NOT rexp									{ rexp.Not($2, parseState.InputStartPosition 1) }
	| rexp BANG				 					{ rexp.Fact($1, parseState.InputStartPosition 2) }
	| MINUS rexp %prec UMINUS 					{ rexp.UMinus($2, parseState.InputStartPosition 1) }
	| INT32					 					{ rexp.Int32($1) }
	| DOUBLE				 					{ rexp.Double($1) }
	| STRING				 					{ rexp.String($1) }
	| CHAR					 					{ rexp.Char($1) }
	| BOOL					 					{ rexp.Bool($1) }
	| NULL LBRACKET tySig RBRACKET  	    	{ rexp.Null($3, parseState.InputStartPosition 3) }
	| TYPE LBRACKET tySig RBRACKET  		    { rexp.Typeof($3, parseState.InputStartPosition 3) }
	| longName				 					{ rexp.Var($1.ToLower(), parseState.InputStartPosition 1)}
	| LPAREN rexp RPAREN		 				{ $2 }
	| longName EQ rexp IN rexp   				{ rexp.Let($1.ToLower(),$3,$5, parseState.InputStartPosition 1) }
	
	| longName LPAREN rexpList RPAREN											
		{ rexp.NameCall($1.ToLower(), [], $3, parseState.InputStartPosition 1) }
	| longName LBRACKET tySigList RBRACKET LPAREN rexpList RPAREN			
		{ rexp.NameCall($1.ToLower(), $3, $6, parseState.InputStartPosition 1) }
	| longName LBRACKET tySigList RBRACKET DOT NAME LPAREN rexpList RPAREN
		{ rexp.GenericTypeStaticCall($1.ToLower(), $3, $6.ToLower(), [], $8, parseState.InputStartPosition 1) }
	| longName LBRACKET tySigList RBRACKET DOT NAME LBRACKET tySigList RBRACKET LPAREN rexpList RPAREN	
		{ rexp.GenericTypeStaticCall($1.ToLower(), $3, $6.ToLower(), $8, $11, parseState.InputStartPosition 1) }
	
	| rexp DOT NAME LPAREN rexpList RPAREN		
		{ rexp.ExpCall($1,$3.ToLower(),[],$5, parseState.InputStartPosition 1) }
	| rexp DOT NAME LBRACKET tySigList RBRACKET LPAREN rexpList RPAREN		
		{ rexp.ExpCall($1,$3.ToLower(),$5,$8, parseState.InputStartPosition 1) }
	
	| rexp SEMICOLON rexp						{ rexp.Sequential($1,$3, parseState.InputStartPosition 3) }
	| OPEN longName IN rexp						{ rexp.Open($2.ToLower(),$4, parseState.InputStartPosition 2) }
	| REF STRING IN rexp						{ rexp.Ref($2, $4, parseState.InputStartPosition 2) }
	| rexp LBRACKET tySig RBRACKET			    { rexp.Cast($1, $3, parseState.InputStartPosition 3) }
	//var expressions must be surrounded by parens in order to be cast in our language... :(