{
module Swensen.NewLang.Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing

let lexeme lexbuf =
    LexBuffer<char>.LexemeString lexbuf

let keywords =
    [
        "and", AND
        "or", OR
        "xor", XOR
        "open", OPEN
        "ref", REF //spell out? "reference" or "open assembly" and "open namespace"
        "in", IN
        "if", IF
        "then", THEN
        "else", ELSE
        "null", NULL
        "type", TYPE
        "true", BOOL(true)
        "false", BOOL(false)
    ] |> Map.ofList
}

// These are some regular expression definitions
let digit = ['0'-'9']
let alpha = (['a' - 'z'] | ['A' - 'Z'])
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

rule tokenize = parse
| whitespace { tokenize lexbuf }
| newline    { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }

// Operators
| "+"  { PLUS }
| "-"  { MINUS }
| "*"  { TIMES }
| "/"  { DIV }
| "^"  { POW }
| "!"  { BANG }
| "~"  { NOT }

| "~=" { NOTEQ }
| "==" { EQEQ }
| ">"  { GT }
| "<"  { LT }
| ">=" { GTEQ }
| "<=" { LTEQ }

//various symbols and keywords (todo: make all word symbols case insensitive)
| "[" { LBRACKET }
| "]" { RBRACKET }
| "(" { LPAREN }
| ")" { RPAREN }
| "." { DOT }
| "," { COMMA }
| ";" { SEMICOLON }
| "="  { EQ }
| "<-" { SET }

//string literal
| '"' [^ '"']* '"' { STRING (let s = lexeme lexbuf in s.Substring(1, s.Length - 2)) }

//char literal
| ''' _ ''' { CHAR (let s = lexeme lexbuf in s.[1]) }

// Numeric constants
| digit+							  { INT32 (lexeme lexbuf |> int) }
| digit+('.'digit+)?(['e''E']digit+)? { DOUBLE (lexeme lexbuf |> float) }

// Names
| (alpha | '_')+(digit | alpha | '_')* 
    { 
        let input = (lexeme lexbuf).ToLower()
        match keywords |> Map.tryFind input with
        | Some(token) -> token
        | None -> NAME(input) 
    }

// EOF
| eof { EOF }