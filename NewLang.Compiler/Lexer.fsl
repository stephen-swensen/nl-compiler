{
module Swensen.NewLang.Lexer
open System
open Parser
open Microsoft.FSharp.Text.Lexing

let lexeme lexbuf =
    LexBuffer<char>.LexemeString lexbuf
}

// These are some regular expression definitions
let digit = ['0'-'9']
let alpha = (['a' - 'z'] | ['A' - 'Z'])
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

rule tokenize = parse
| whitespace { tokenize lexbuf }
| newline    { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }

// Operators
| "+"  { PLUS }
| "-"  { MINUS }
| "*"  { TIMES }
| "/"  { DIV }
| "^"  { POW }
| "!"  { BANG }
// | "!=" { NOTEQ }
// | "==" { EQ }
// | ">"  { GT }
// | "<"  { LT }
// | ">=" { GTEQ }
// | "<=" { LTEQ }

//various symbols and keywords
| "[" { LBRACKET }
| "]" { RBRACKET }
| "(" { LPAREN }
| ")" { RPAREN }
| "." { DOT }
| "," { COMMA }
| ";" { SEMICOLON }
| "open" { OPEN }
| "ref" { REF }
| "="  { EQ }
| "in" { IN }

//bool literals
| "true"  { BOOL (true) }
| "false" { BOOL (false) } 

//null literal
| "null" { NULL }

//type literal
| "type" { TYPE }

//string literal
| '"' [^ '"']* '"' { STRING (let s = lexeme lexbuf in s.Substring(1, s.Length - 2)) }

//char literal
| ''' _ ''' { CHAR (let s = lexeme lexbuf in s.[1]) }

// Numeric constants
| digit+							  { INT32 (lexeme lexbuf |> int) }
| digit+('.'digit+)?(['e''E']digit+)? { DOUBLE (lexeme lexbuf |> float) }

// Names
| (alpha | '_')+(digit | alpha | '_')* { NAME (lexeme lexbuf |> string) }

// EOF
| eof { EOF }